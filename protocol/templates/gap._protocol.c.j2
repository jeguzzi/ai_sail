{%- from "macros.j2" import typedef -%}

#include "protocol.h"

#define HEADER_LENGTH 4
#define UART_RX_PROTOCOL
static PI_L2 uint8_t header[HEADER_LENGTH];
static pi_task_t task;

{%- for data_t in config.configs + config.inputs %}
void send_{{data_t.name}}_config({{data_t.typename}} *config)
{
  if(!enabled) return;
#ifdef {{data_t.name | upper}}_HEADER
  pi_uart_write(&device, {{data_t.name | upper}}_HEADER, HEADER_LENGTH);
  pi_uart_write(&device, (uint8_t *)config, sizeof({{data_t.typename}}));
#endif
}
{% endfor %}

static void received_header(void *arg)
{
{% for data_t in config.configs %}
#ifdef {{data_t.name | upper}}_HEADER
  if(memcmp(header, {{data_t.name | upper}}_HEADER, HEADER_LENGTH) == 0)
  {
    PI_L2 uint8_t rx_buffer[sizeof({{data_t.typename}})];
    if(pi_uart_read(&device, rx_buffer, sizeof({{data_t.typename}})))
    {
      LOG_ERROR("Failed to read {{data_t.name}} config\n");
    }
    else{
      set_{{data_t.name}}_config(({{data_t.typename}} *)rx_buffer);
    }
    goto: done
  }
#endif
{% endfor %}
  done: pi_uart_read_async(&device, header, HEADER_LENGTH, &task);
}

static void start_rx_protocol()
{
  pi_task_callback(&task, (void *) received_header, &task);
  pi_uart_read_async(&device, header, HEADER_LENGTH, &task);
}
